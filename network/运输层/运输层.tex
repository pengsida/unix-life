% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=bash,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

\newcommand{\interval}{\vspace{0.5em}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{运输层 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

% \tableofcontents

% \clearpage

\section{概述和运输层服务}
	报文段：在发送端中运输层将从发送应用程序进程接收到的报文转换为运输层分组，这个分组成为报文段。

\subsection{运输层和网络层的关系}
	网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信，运输层刚好位于网络层之上。\par

	运输层提供的服务受制于网络层所能提供的服务。不过即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。
	比如即使底层网络协议是不可靠的，运输层协议也能为应用程序提供可靠的数据传输服务。

\subsection{因特网运输层概述}
	因特网为应用层提供了两种运输层协议：用户数据报协议UDP和传输控制协议TCP。\par

	UDP提供的服务：
	\begin{itemize}
		\item 进程到进程的数据交付。
		\item 进程到进程的数据差错检查。
	\end{itemize}

	TCP提供的服务：
	\begin{itemize}
		\item 进程到进程的数据交付。
		\item 进程到进程的数据差错检查。
		\item 可靠数据传输。
		\item 拥塞控制。
	\end{itemize}

\section{多路复用与多路分解}
	课本第127页有运输层工作的例子。\par

	多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层。\par

	多路分解：将运输层报文段中的数据交付到正确的套接字。\par

	运输层多路复用的要求：
	\begin{itemize}
		\item[1.] 套接字有唯一标识符。
		\item[2.] 每个报文段有特殊字段来指示该报文段所要交付到的套接字。这些特殊字段包括源端口号字段和目的端口号字段。
	\end{itemize}

	端口号：一个16比特的数，大小在0～65535之间。其中0～1023的端口号称为周知端口号，用于保留给周知的应用层协议。

\subsection{无连接的多路复用与多路分解}
	一个UDP套接字由一个二元组来标识：(目的IP地址，目的端口号)。\par

	一般来说，运输层自动地为应用程序的客户端分配唯一的端口号，为服务器端分配一个特定的端口号。\par

	课本第129页有UDP复用与分解的例子。

\subsection{面向连接的多路复用与多路分解}
	一个TCP套接字由一个四元组来标识：(源IP地址，源端口号，目的IP地址，目的端口号)。\par

	也就是说，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字。\par

	课本第130页有TCP复用与分解的例子。

\section{无连接运输：UDP}
	UDP的三个特点：
	\begin{itemize}
		\item[1.] UDP从应用程序得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。
		\item[2.] 在接收主机上，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。
		\item[3.] 没有拥塞控制。
	\end{itemize}

	称UDP为无连接的原因：在发送报文段之前，发送方和接收方的运输层实体之间没有握手。\par

	DNS是使用UDP的一个例子，见课本第133页。\par

	UDP优于TCP的方面：
	\begin{itemize}
		\item[1.] 关于何时、发送什么数据的应用层控制更为精细。
		\item[2.] 无需建立连接。
		\item[3.] 不需要维护连接状态，可以支持更多的活跃客户。
		\item[4.] 分组首部开销小，UDP的首部只有8字节的开销。
	\end{itemize}

\subsection{UDP报文段结构}
	UDP报文段结构如下：
	\begin{itemize}
		\item 一个首部，有四个字段：
			\begin{itemize}
				\item 源端口号字段和目的端口号字段，UDP通过端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。
				\item 长度字段，指示了UDP报文段的字节数。
				\item 检验和，用于检查该报文段是否出现了差错。
			\end{itemize}

		\item 一个数据字段，用于装载应用层数据。
	\end{itemize}

\subsection{UDP检验和}
	检验和的作用：确定当UDP报文段从源到达目的地移动时，其中的比特是否发生了改变。\par

	求检验和的步骤：
	\begin{itemize}
		\item[1.] 对报文段首部中的其他三个字段求和，如果加法有溢出，就将该溢出回卷。
		\item[2.] 将第一步得到的结果求反码，然后存放在UDP报文段中的检验和字段。
	\end{itemize}

	利用检验和进行差错检测的方法：
	\begin{itemize}
		\item[1.] 接收方将报文段首部的4个字段加在一起。
		\item[2.] 检验第一步中得到的结果，如果所有比特全为1，则说明没有出错。
	\end{itemize}

	需要知道的是，UDP只提供了差错检测，但它对差错恢复无能为力。

\section{可靠数据传输原理}
	可靠数据传输的定义：
	\begin{itemize}
		\item[1.] 传输数据比特不会受到损坏或丢失。
		\item[2.] 所有数据都是按照其发送顺序进行交付。
	\end{itemize}

\subsection{构造可靠数据传输协议}
\subsubsection{经完全可靠信道的可靠数据传输：rdt1.0}
	考虑最简单的情况：底层信道是完全可靠的。\par

	课本第138页画出了rdt1.0的有限状态机，需要知道的是，发送方和接收方都有各自的FSM。\par

	在发送端，由较高层应用调用产生rdt\_send(data)事件，然后产生两个动作：
	\begin{itemize}
		\item[1.] 经由make\_pkt(data)动作产生一个包含该数据的分组packet。
		\item[2.] 经由udt\_send(packet)动作将分组发送到信道中。
	\end{itemize}

	在接收端，由较低层协议调用产生rdt\_rcv(packet)动作，然后产生两个动作：
	\begin{itemize}
		\item[1.] 经由extract(packet, data)动作从分组中取出数据。
		\item[2.] 通过deliver\_data(data)动作将数据上传给较高层的应用。
	\end{itemize}

\subsubsection{经具有比特差错信道的可靠数据传输：rdt2.0}
	假设底层信道：
	\begin{itemize}
		\item[1.] 分组中的比特可能受损。
		\item[2.] 所有发送的分组将按其发送的顺序被接收，不会发生丢包。
	\end{itemize}

	自动重传协议(ARQ协议)：使用控制报文“肯定确认(ACK)”和“否定确认(NAK)”。“肯定确认”让发送方知道哪些内容被正确接收，
	“否定确认”让发送方知道哪些内容接收有误并因此需要重复。\par

	ARQ协议中的其他三种协议功能：
	\begin{itemize}
		\item[1.] 差错检测，使得接收方检测到何时出现了比特差错。
		\item[2.] 接收方反馈，让接收方向发送方会送ACK与NAK分组。
		\item[3.] 重传，接收方收到有差错的分组时，发送方将重传该分组文。
	\end{itemize}

	课本第139页画出了rdt2.0的有限状态机。\par

	发送端状态机的描述：
	\begin{itemize}
		\item[1.] 发送端首先处于等待来自上层的调用的状态。
		\item[2.] 上层调用时发生rdt\_send(data)的事件，产生sndpkt=make\_pkt(data, checksum)和udt\_send(sndpkt)的动作，随后进入等待ACK或NAK的状态。
		\item[3.] 处于等待ACK或NAK的状态时，如果发生rdt\_rcv(rcvpkt)\&\&isNAK(rcvpkt)的事件，就产生udt\_send(sendpkt)的动作，并回到等待ACK或NAK的状态。
				  如果发生rdt\_rcv(rcvpkt)\&\&isACK(rcvpkt)的事件，就回到等待来自上层的调用的状态。
	\end{itemize}

	需要知道的是，当发送方处于等待ACK或NAK的状态，它不能从上层获得更多的数据。所以rdt2.0协议又称为停等协议。\par

	接收端状态机的描述：
	\begin{itemize}
		\item[1.] 接收端处于等待来自下层的调用的状态。
		\item[2.] 如果发生rdt\_rcv(rcvpkt)\&\&corrupt(rcvpkt)事件，说明收到的分组受损，然后产生sndpkt=make\_pkt(NAK)和udt\_send(sndpkt)的动作。
				  如果发生rdt\_rcv(rcvpkt)\&\&notcorrupt(rcvpkt)事件，说明收到的分组没有受损，然后产生extract(rcvpkt, data)
				  ，deliver\_data(data)，sndpkt=make\_pkt(ACK)和udt\_send(sndpkt)的动作。
	\end{itemize}

	rdt2.0的缺陷：没有考虑到ACK或NAK分组受损的可能性。如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。\par
	解决方法：当发送方接收到含糊不清的ACK或NAK分组时，只需要重传当前数据分组即可。
	该方法引入的新问题：信道中出现了冗余分组，接收方不知道它接收到的分组是新分组还是一次重传。\par

	针对新问题的解决方法：在数据字段添加一个新字段，让发送方对其数据分组编号，将发送数据分组的序号放在该字段。
	该字段只需要1比特：0或1。如果接收方接收到的分组序号与上一次接收到的分组序号相同，就说明这是一次重传。
	ACK或NAK分组不需要指明确认的分组序号，因为这里假设不丢失分组，所以它们一定是为响应这一次发送的数据分组而生成的。\par

	课本第141页有rdt2.1发送方的状态图，第142页有rdt2.1接收方的状态图。\par

	rdt2.2通过在ACK分组中加入分组序号，实现了无NAK的可靠数据传输协议。
	如果接收方收到受损的分组时，它发送一个带有上一次数据分组序号的ACK分组。
	发送方接收到同一分组的两个ACK分组时，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组。\par

	课本第142页有rdt2.2发送方的状态图，第143页有rdt2.2接收方的状态图。\par

\subsubsection{经具有比特差错信道的丢包信道的可靠数据传输：rdt3.0}
	协议新关注的两个问题：怎么检测丢包以及发生丢包后该做些什么。\par

	如何检测丢包：发送方等待足够长的时间，如果没有接收到接收方的响应，就默认丢包。\par

	发生丢包后该做些什么：只需要重传该数据分组。\par

	如果没有发生丢包又重传时，信道中将引入冗余数据分组。我们在rdt2.1中已经解决了这个问题。\par

	实现一个基于时间的重传机制：
	\begin{itemize}
		\item[1.] 每次发送一个分组时，就启动一个定时器。
		\item[2.] 响应定时器中断，从而采取适当的动作。
		\item[3.] 终止定时器。
	\end{itemize}

	因为分组序号在0和1之间交替，所以rdt3.0被称为比特交替协议。\par

	课本第144页有rdt3.0发送方的状态图，第145页有rdt3.0的运行举例。\par

	课本第144～146页有rdt协议的效率分析。

\subsection{流水线可靠数据传输协议}
	流水线：不使用停等方式运行，允许发送方发送多个分组而无需等待确认，许多从发送方向接收方输送的分组可以被看成是填充到一条流水线中。\par

	解决流水线的差错恢复的两种基本方法：回退N步和选择重传。

\subsubsection{回退N步}
	回退N步协议：允许发送方发送多个分组而不需等待确认，也受限于在流水线中未确认的分组数不能超过某个最大允许数N。\par

	基序号：最早的未确认分组的序号。下一个序号：下一个待发分组的序号。\par

	课本第148页有GBN发送方的状态图，第149页有GBN接收方的状态图。\par

	GBN发送方需要响应三种类型的事件：
	\begin{itemize}
		\item 上层的调用。首先判断是否超过N，如果窗口未满，则产生一个分组并将其发送，并相应地更新分量。如果窗口已满，发送方只需将数据返回给上层。
		\item 收到一个ACK。采取累积确认的方式，发送方接收到的ACK附带的序号为n，就默认n之前且包括n的分组全部被接收方接收到。
		\item 超时事件。如果出现超时，发送方将重传已发送但未被确认过的分组。接收到一个ACK时，如果仍有已发送但未被确认的分组，则定时器被重新启动。
			  如果没有已发送但未被确认的分组，该定时器被终止。
	\end{itemize}

	GBN接收方需要响应的事件：
	\begin{itemize}
		\item 一个分组n根据正确的序号被接收到，则接收方为分组n发送ACK，并将其数据交付给上层。
		\item 在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。根据这个机制，发送方getacknum(rcvpkt)得到的肯定是最近按序接收的分组序号，这保证了数据的按序交付。
	\end{itemize}

	课本第150页有对GBN运行的举例。\par

	因为GBN协议未确认的分组数不能超过某个最大允许数N，这被视为一个窗口，GBN协议也被称为滑动窗口协议。

\subsubsection{选择重传}
	GBN协议的缺陷：单个分组的差错就能够引起GBN重传大量分组，随着信道差错率的增加，流水线可能会被这些不必要重传的分组所充斥。\par

	选择重传：通过让发送方仅重传那些它怀疑在接受方出错的分组而避免不必要的重传。\par

	SR发送方需要处理的事件：
	\begin{itemize}
		\item 从上层收到数据。如果序号位于发送方的窗口内，则将数据打包并发送。
		\item 超时。现在每个分组必须拥有其自己的逻辑定时器，因为超时发生后职能发送一个分组。
		\item 收到ACK。如果ACK携带的分组序号位于窗口内，则SR发送方将那个被确认的分组标记为已接收。
			  如果该分组的序号等于send\_base，则窗口基序号向前移动到具有最小序号的未确认分组处。
	\end{itemize}

	SR接收方也建立了一个窗口N，用于限制流水线中未完成、未被确认的分组数。
	SR接收方需要处理的事件：
	\begin{itemize}
		\item 收到的分组落在接受方的窗口内，产生一个ACK分组回送给发送方。
			  如果分组以前从未收到过，则缓存该分组。
			  如果分组序号等于rcv\_base，则窗口向前移动到具有最小序号的未缓存分组处。
		\item 收到的分组序号小于rcv\_base，此时必须产生一个ACK分组回送给发送方，这是考虑到了之前传给发送方的ACK可能丢失。
		\item 其他情况，则忽略该分组。
	\end{itemize}

	课本第152页有SR操作的例子。\par

	当分组序号范围有限时，窗口大小选择不当将产生严重的后果。课本第153页有一个相应的例子。
	窗口长度必须小于或等于分组序号空间大小的一半。\par

\subsection{可靠数据传输机制的总结}
	实现可靠数据传输的机制：
	\begin{itemize}
		\item 检验和，用于检测在一个分组中的比特错误。
		\item 定时器，用于超时重传一个数据分组，因为一个数据分组或ACK分组可能在信道中丢失了。
			  如果一个分组延时但未丢失，导致过早超时，信道中就会出现冗余数据分组。
		\item 序号，具有相同序号的数据分组可使接收方检测出一个分组的冗余副本。接收分组序号间的空隙还可以使接收方检测出丢失的分组。
		\item 肯定确认ACK，用于告诉接收方一个分组或一组分组已被正确接收到了。
		\item 否定确认NAK，用于告诉发送方某个分组未被正确地接收。
		\item 窗口、流水线，用于提高发送方的利用率。
	\end{itemize}

\subsection{分组重新排序问题}
	当连接发送方和接收方两端的信道是一个网络时，分组重新排序是可能发生的。\par

	分组重新排序的表现：一个具有序号或确认号x的分组的旧副本可能会出现，即使发送方或接收方的窗口中都没有包含x。
	这就相当于信道缓存了分组，并在将来任意时刻自然地释放出这个分组。
	因为序号x可以背重新使用，一旦该分组被释放，将导致错误的发生。\par

	解决方法：确保序号x不被重新使用，知道发送方确信任何先前发送的序号为x的分组都不再在网络中为止。

\section{面向连接的运输：TCP}
\subsection{TCP的基本概念}
	TCP的特点：
	\begin{itemize}
		\item[1.] 提供全双工服务。
		\item[2.] TCP连接是点对点的。
		\item[3.] TCP连接的组成包括：一台主机上的缓存、变量与进程连接的套接字，以及另一台主机上的另一组缓存、变量和雨进程连接的套接字。两台主机间的网络元素没有为该连接提供任何缓存和变量。
	\end{itemize}

	最大传输单元MTU：指的是从源主机到目的主机间所有链路上发送的最大链路层帧长度，典型值为1500字节。\par

	最大报文段长度MSS：需要保证一个TCP报文段加上TCP/IP首部可以适合一个链路层帧。TCP/IP首部长度通常为40字节，所以MSS的典型值为1460字节。

\subsection{TCP报文段结构}
	TCP报文段结构如下：
	\begin{itemize}
		\item 16比特的源端口号和16比特的目的端口号。
		\item 32比特的序号和32比特的确认号，用于实现可靠数据传输服务。TCP对序号的使用是基于字节流而不是基于报文段的，所以一个报文段的序号是该报文段首字节的字节流序号。
			  而确认号是目的主机期望从源主机收到的下一字节的序号。因为TCP只确认字节流中到第一个丢失字节为止的字节，所以TCP提供的是累积确认。课本第159页给出了使用序号和确认号的例子。
		\item 16比特的接收窗口字段，用于流量控制。
		\item 16比特的检验和字段。
		\item 4比特的首部长度字段，单位为字。
		\item 6比特的标志字段：
			\begin{itemize}
				\item ACK比特用于确认字段中的值是有效的。
				\item RST、SYN和FIN用于连接建立和拆除。
				\item PSH比特用于指示接收方应立即将数据上交给上层。
				\item URG比特用于指示报文段里存在着被发送端置为“紧急”的数据。
			\end{itemize}

		\item 16比特的紧急数据指针字段，用于指向紧急数据的最后一个字节。
		\item 可选与长度可变的选项字段。
		\item 数据字段。
	\end{itemize}

	课本第157页画出了TCP报文段结构。

\subsection{往返时间的估计与超时}
	TCP中使用超时重传机制，所以超时间隔必须大于该连接的往返时间。\par

	TCP估计往返时间的方法：在任意时刻，为一个已发送但目前未被确认的报文段估计SampleRTT。TCP仅在某一时刻做一次SampleRTT测量，而且绝不为已被重传的报文段计算SampleRTT。\par

	课本的第161页还讨论了EstimatedRTT和DevRTT这两个概念。TCP的超时间隔计算公式如下：
	\begin{equation}
		TimeoutInterval = EstimatedRTT + 4\times DevRTT
	\end{equation}

\subsection{可靠数据传输}
	TCP发送方对三个事件的响应：
	\begin{itemize}
		\item 上层的调用。TCP从应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP。
		\item 超时。TCP将重传具有最小序号的未确认的报文，并重启定时器。需要注意的是，TCP中只有一个定时器。
		\item 接收来自接收方的ACK。ACK携带序号y，发送方记载着最早未被确认的字节的序号SendBase。
			  TCP采用累积确认，所以y确认了序号在y之前且包括y的所有字节都已经收到，并且重启定时器。
	\end{itemize}

	课本第164～165页给出了可靠传输的例子。

\subsubsection{超时间隔加倍}
	如果TCP响应超时事件，那么TimeoutInterval将是先前值的两倍。
	而如果定时器在另两个事件(上层的调用、接收到ACK)中的任意一个启动，TimeoutInterval的值将有EstimatedRTT和DevRTT决定。

\subsubsection{快速重传}
	TCP不使用否认确认，而是使用冗余ACK进行否定确认。当接收方接收到一个比期望序号大的失序报文段，接收方检测出间隔，并发送冗余ACK，指示下一个期待字节的序号。\par

	快速重传：一个收到3个冗余ACK，TCP就执行快速重传，也就是在该报文段的定时器过期之前重传丢失的报文段。

\subsection{流量控制}
	一条TCP连接每一侧的主机都为该连接设置了接收缓存，如果接收方读取数据的速度慢于发送方发送数据的速度，那么该连接的接收缓存可能溢出。\par

	流量控制服务：使得发送方的发送速率与接收方的读取速率相匹配。\par

	实现方法：
	\begin{itemize}
		\item[1.] 接收方定义三个变量，RcvBuffer表示接收缓存的大小，LastByteRead表示从缓存读出的数据流的最后一个字节的编号，LastByteRcvd表示从网络中接收的数据流的最后一个字节的编号。
		\item[2.] 接收方维持一个接收窗口的变量rwnd，使得$rwnd=RcvBuffer-[LastByteRcvd - LastByteRead]$。
		\item[3.] 接收方将当前rwnd值放入发给发送方的报文段中的接收窗口字段中，让发送方知道rwnd的值。
		\item[4.] 发送方定义两个变量，LastByteSent和LastByteAckd，两者之差表示发送到连接中但未被确认的数据量。
			      只要让这个值小于rwnd，就能保证接收缓存不会溢出。
	\end{itemize}

	流量控制的缺陷：当rwnd=0时，将导致发送方不会再发报文给接收方，从而接收方也不会发确认报文给发送方，发送方中的rwnd值得不到更新，发送方就会被阻塞而不能再发送数据。\par

	上述缺陷的解决方法：当rwnd=0时，发送方继续发送只有一个字节数据的报文段，这些报文段将会被接收方接收被返回相应的确认报文。

\subsection{TCP连接管理}
	客户TCP通过如下步骤与服务器TCP建立一条连接：
	\begin{itemize}
		\item[1.] 客户端的TCP向服务器的TCP发送一个特殊的TCP报文段，称为SYN报文段。报文段中SYN比特置为1，序号字段中随机选择一个初始序号client\_isn，数据字段中不包含应用层的数据。
		\item[2.] SYN报文段到达服务器主机后，服务器开始分配TCP缓存和变量，并发送SYNACK报文段。SYNACK报文段中SYN比特置为1，序号字段随机选择一个初始序号server\_isn，数据字段中不包含应用层的数据。
		\item[3.] SYNACK报文段到达客户端主机后，客户开始分配TCP缓存和变量，并发送确认报文。报文中SYN比特为0，确认号为server\_isn+1，数据字段包含应用层的数据。
	\end{itemize}

	连接创建过程称为3次握手，在连接创建之后，每一个报文段中的SYN比特都将被置为0。\par

	课本第171～172页讲了TCP连接拆除的例子。\par

	TCP建立过程还有一种可能：服务器TCP接收到SYN报文段，但是SYN报文段中的端口号或源IP地址与服务器主机上的套接字不匹配，那么主机将向源发送一个重置报文段。
	该报文段中RST比特置为1，用于告诉源主机“我没有那个报文段的套接字，请不要再发送该报文段了”。

\end{document}
